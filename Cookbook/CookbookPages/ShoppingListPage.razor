@page "/shoppinglistpage";
@using OrganizerBlazor.Auth.Service;
@using OrganizerBlazor.Cookbook.Models.CookBookDTO;
@using System.Net.Http.Headers;
@using OrganizerBlazor.Cookbook.Models;

@inject HttpClient Http
@inject ILocalStorageService LocalStorageService
@inject NavigationManager NavigationManager
@inject IAuthUtils authUtils
@attribute [Authorize]

<link rel="stylesheet" href="../css/cookbook/shoppingListPage.css">

<div class="shoppinglist-page-box">

    @if(LoadingData)
    {
        <div class="loading-box">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <h3>Loading shoppinglist...</h3>
        </div>
    }
    else
    {
        <div class="shopping-all-data">
            <div class="shopping-box">
                <h3>Shopping list</h3>

                @if (!ShowMergedList)
                {
                    @if(shoppingList.SingleShopListRecipes.Count > 0 || shoppingList.AdditionalItems.Count > 0)
                    {
                        <div class="merge-box">
                            <button @onclick="ShowSeparatedList">Separated</button>
                            <button @onclick="ShowMergedShoppingList">Merged</button>
                        </div>
                        <div class="one-recipe-shopping-box">
                            @if (shoppingList != null || shoppingList.SingleShopListRecipes.Count > 0)
                            {
                                @foreach (var recipeShoppingData in shoppingList.SingleShopListRecipes)
                                {
                                    <div class="recipe-name-box">
                                        <h4>@recipeShoppingData.RecipeName</h4>
                                        <span @onclick="() => {RemoveWholeRecipeFromShoppingList(recipeShoppingData.RecipeName);}" class="remove-icon">🗑️</span>
                                    </div>
                                    @foreach (var ingredient in recipeShoppingData.Ingredients)
                                    {
                                        var isStriked = strikedIngredients.ContainsKey(ingredient.Guid.ToString()) && strikedIngredients[ingredient.Guid.ToString()];
                                        <div @onclick="() => ToggleStriked(ingredient.Guid.ToString())" class="ingr-item list-group-item @((isStriked) ? "striked" : "")">
                                            @ingredient.Name - @ingredient.Quantity @ingredient.Unit
                                            <span @onclick:stopPropagation="true" @onclick="() => RemoveIngredient(ingredient.Guid.ToString())" class="remove-icon">🗑️</span>
                                        </div>
                                    }
                                }
                            }
                        </div>
                        <div class="extra-items-shooping-box">
                            @if (shoppingList.AdditionalItems != null && shoppingList.AdditionalItems.Count > 0)
                            {
                                <div class="additional-list-group">
                                    <i>Extra</i>
                                    @foreach (var item in shoppingList.AdditionalItems)
                                    {
                                        var isStriked = strikedAdditionalItems.ContainsKey(item) && strikedAdditionalItems[item];
                                        <div @onclick="() => ToggleStrikedAdditionalItem(item)" class="extra-ingr-item list-group-item @((isStriked) ? "striked" : "")">
                                            @item
                                            <span @onclick="() => RemoveAdditionalItem(item)" @onclick:stopPropagation="true" class="remove-icon">🗑️</span>
                                        </div>
                                    }
                                </div>
                            }
                        </div>
                    }
                    else
                    {
                        <p>Shoppinglist is empty!</p>
                    }
                }
                else
                {
                    //display merged list same way
                    @foreach(var item in mergedList)
                    {
                        var isStriked = strikedAdditionalItems.ContainsKey(item) && strikedAdditionalItems[item];
                        <div @onclick="() => ToggleStrikedAdditionalItem(item)" class="extra-ingr-item list-group-item @((isStriked) ? "striked" : "")">
                            @item
                            <span @onclick="() => RemoveItemFromMerged(item)" @onclick:stopPropagation="true" class="remove-icon">🗑️</span>
                        </div>
                    }
                }
                <div class="add-additional-items-box">
                    @* <label>Add additional item:</label> *@
                    <input type="text" @bind="currentItemName" placeholder="item name" />
                    <button @onclick="AddItemToList">add</button>
                </div>
            </div>
            
             

            <div class="additional-stuff-box">

                <div class="additional-history-box">
                    @if (earlierAddedITems != null && earlierAddedITems.Count > 0)
                    {
                        <h4>History</h4>
                        <div class="list-group addittional-items-box">
                            @foreach (var item in earlierAddedITems)
                            {
                                <div @onclick="() => AddEarlierItemToShoppingList(item)" class="history-add-item">
                                    <p class="history-item-p">@item</p>
                                    <span @onclick:stopPropagation="true" @onclick="() => RemoveItemFromAdditionalList(item)" class="remove-icon">🗑️</span>
                                </div>
                            }
                        </div>
                    }
                </div>

                <div class="additional-recommended-box"> 
                    @if(recommendedItems.Count > 0)
                    {
                            <h4>Recommended</h4>
                            @foreach(var recItem in recommendedItems)
                            {
                                <p class="rec-item-p" @onclick="() => AddEarlierItemToShoppingList(recItem)">@recItem</p>
                            }
                    }
                </div>
            
            </div>
        </div>

        <button @onclick="SaveShoppingListToBackend">save shopping list</button>
    }

</div>

@code {
    private bool LoadingData = true;
    private Dictionary<string, bool> strikedIngredients = new Dictionary<string, bool>();
    private Dictionary<string, bool> strikedAdditionalItems = new Dictionary<string, bool>();
    private List<string>? earlierAddedITems = new();
    private string currentItemName;
    private SingleShopList? shoppingList = new();
    private List<string> recommendedItems = new();
    private List<string> mergedList = new();
    private bool ShowMergedList = false;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        getShoppingListFromBackend();

    }

    private async void getShoppingListFromBackend()
    {
        try
        {
            string tokenToSet = await LocalStorageService.GetItemAsync<string>("JwtToken");
            Http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", tokenToSet);

            var response = await Http.GetAsync("shoppinglist/get-shoppinglist");

            if (!response.IsSuccessStatusCode)
            {
                if (response.StatusCode == System.Net.HttpStatusCode.Unauthorized)
                {
                    // If the status code is 401, clear the credentials and redirect.
                    await authUtils.RemoveCredentialsAsync();
                    return;
                }
                // Handle other non-success status codes appropriately
                return;
            }

            var shoppingListData = await response.Content.ReadFromJsonAsync<ShoppingListPageDTO>();
            if (shoppingListData.SingleShopList != null && shoppingListData.AdditionalItems != null)
            {
                shoppingList = shoppingListData.SingleShopList;
                earlierAddedITems = shoppingListData.AdditionalItems;
                recommendedItems = shoppingListData.RecommendedAdditionalItems;
            }

            // ---- fake recommended items for design ----
            recommendedItems = new() { "item1", "item2", "item3", "item4" };

        }
        catch (Exception e)
        {
            // Handle any exceptions here
            Console.WriteLine($"Exception in getShoppingListFromBackend: {e.Message}");
        }
        finally
        {
            LoadingData = false;
            StateHasChanged();
        }
    }

    private void ToggleStriked(string ingredientGuid)
    {
        if (strikedIngredients.ContainsKey(ingredientGuid))
        {
            strikedIngredients[ingredientGuid] = !strikedIngredients[ingredientGuid];
        }
        else
        {
            strikedIngredients[ingredientGuid] = true;
        }
    }

    private void AddItemToList()
    {
        shoppingList.AdditionalItems.Add(currentItemName);
        earlierAddedITems.Add(currentItemName);
        currentItemName = "";
    }

    private void ToggleStrikedAdditionalItem(string item)
    {
        if (strikedAdditionalItems.ContainsKey(item))
        {
            strikedAdditionalItems[item] = !strikedAdditionalItems[item];
        }
        else
        {
            strikedAdditionalItems[item] = true;
        }
    }

    private void RemoveIngredient(string ingredientGuid)
    {

        SingleShopListRecipe recipeToRemove = null;
        // i can search directly on ingredient id since theres slim to no chance of duplicates
        foreach (var recipe in shoppingList.SingleShopListRecipes)
        {
            var ingredientToRemove = recipe.Ingredients.FirstOrDefault(ingr => ingr.Guid.ToString() == ingredientGuid);
            if (ingredientToRemove != null)
            {
                recipe.Ingredients.Remove(ingredientToRemove);
                if (recipe.Ingredients.Count == 0)
                {
                    recipeToRemove = recipe;
                }
                break; // If you only expect one ingredient with this Guid, you can break the loop once found.
            }
        }

        if (recipeToRemove != null)
        {
            shoppingList.SingleShopListRecipes.Remove(recipeToRemove);
        }

        // Optionally remove the ingredient from the strikedIngredients as well
        strikedIngredients.Remove(ingredientGuid);
    }

    private void RemoveAdditionalItem(string item)
    {
        shoppingList.AdditionalItems.Remove(item);

        // Optional: Remove from striked list
        if (strikedAdditionalItems.ContainsKey(item))
        {
            strikedAdditionalItems.Remove(item);
        }
    }

    private async void SaveShoppingListToBackend()
    {
        LoadingData = true;
        StateHasChanged();
        //make post request
        try
        {
            string tokenToSet = await LocalStorageService.GetItemAsync<string>("JwtToken");
            Http.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", tokenToSet);

            ShoppingListPageDTO updatedShopList = new ShoppingListPageDTO()
                {
                    SingleShopList = shoppingList,
                    AdditionalItems = earlierAddedITems
                };

            var response = await Http.PostAsJsonAsync("shoppinglist/update-shoppinglist", updatedShopList);

            if (!response.IsSuccessStatusCode)
            {
                //show error message
                return;
            }
            else{
                getShoppingListFromBackend();
                LoadingData = false;
                StateHasChanged();
            }
        }
        catch (Exception e)
        {
            Console.WriteLine("im in catch!");
            Console.WriteLine(e.Message);
        }
    }

    private void AddEarlierItemToShoppingList(string item)
    {
        // Add the item to the shoppingList
        shoppingList?.AdditionalItems.Add(item);
    }

    private void RemoveItemFromAdditionalList(string itemName)
    {
        earlierAddedITems?.RemoveAll(item => item == itemName);
    }

    private void RemoveWholeRecipeFromShoppingList(string recipeName)
    {
        shoppingList?.SingleShopListRecipes.RemoveAll(d => d.RecipeName == recipeName);
    }

    private void ShowMergedShoppingList()
    {

        mergedList.Clear();

        //only do merge if it is empty
        if(mergedList.Count == 0)
        {
            //take all items from all shopping recipies and add to temporary list with all ingredients
            List<Ingredient> tempIngr = shoppingList.SingleShopListRecipes
                                         .SelectMany(recipe => recipe.Ingredients)
                                         .ToList();



            for(int i = 0; i< tempIngr.Count-1; i++)
            {
                string tempName = "";
                tempName += $"{tempIngr[i].Name} : {tempIngr[i].Quantity}{tempIngr[i].Unit}";

                // a second for loop to check ahead in list and find duplicate names
                for(int j = i + 1 ;j < tempIngr.Count; j++)
                {
                    if(tempIngr[i].Name == tempIngr[j].Name)
                    {
                        tempName += $" {tempIngr[j].Quantity}{tempIngr[j].Unit} ";
                        tempIngr.RemoveAt(j);
                        j--;
                    }
                }

                mergedList.Add(tempName);
                tempName = " ";
            }

            //add the extra items aswell
            mergedList.AddRange(shoppingList.AdditionalItems);
        }

        ShowMergedList = true;
        StateHasChanged();
    }

    private void ShowSeparatedList()
    {
        ShowMergedList = false;
        StateHasChanged();
    }

    private void RemoveItemFromMerged(string nameToRemove)
    {

        //separate name from wuant and unit by blank space
        var nameSeparated = nameToRemove.Split(" :")[0];

        //go trough normal list and addiotnal item list and remove wehre name is same
        foreach (var recipe in shoppingList.SingleShopListRecipes)
        {
            recipe.Ingredients = recipe.Ingredients
                .Where(ingredient => !ingredient.Name.Equals(nameSeparated))
                .ToList();
        }

        shoppingList.AdditionalItems = shoppingList.AdditionalItems
            .Where(item => !item.Equals(nameSeparated))
            .ToList();

        //since nameToRemove comes from mergedList i dont need to manipulate the string for that one
        mergedList = mergedList
            .Where(name => !name.StartsWith(nameSeparated))
            .ToList();

        //remove whole recipies where they have no ingredients in specified view
        shoppingList.SingleShopListRecipes = shoppingList.SingleShopListRecipes
            .Where(recipe => recipe.Ingredients.Count > 0)
            .ToList();

        StateHasChanged();

    }
}
